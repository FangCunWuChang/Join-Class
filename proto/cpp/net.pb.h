// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "task.pb.h"
#include "class.pb.h"
#include "user.pb.h"
#include "student.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_2eproto;
namespace JC {
namespace Net {
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class AnswerPack;
struct AnswerPackDefaultTypeInternal;
extern AnswerPackDefaultTypeInternal _AnswerPack_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestPack;
struct RequestPackDefaultTypeInternal;
extern RequestPackDefaultTypeInternal _RequestPack_default_instance_;
}  // namespace Net
}  // namespace JC
PROTOBUF_NAMESPACE_OPEN
template<> ::JC::Net::Answer* Arena::CreateMaybeMessage<::JC::Net::Answer>(Arena*);
template<> ::JC::Net::AnswerPack* Arena::CreateMaybeMessage<::JC::Net::AnswerPack>(Arena*);
template<> ::JC::Net::Request* Arena::CreateMaybeMessage<::JC::Net::Request>(Arena*);
template<> ::JC::Net::RequestPack* Arena::CreateMaybeMessage<::JC::Net::RequestPack>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace JC {
namespace Net {

enum Request_Type : int {
  Request_Type_LOGIN = 0,
  Request_Type_GETUSERLIST = 1,
  Request_Type_ADDUSER = 2,
  Request_Type_CHANGEUSER = 3,
  Request_Type_DELUSER = 4,
  Request_Type_GETCONFIG = 5,
  Request_Type_SETCONFIG = 6,
  Request_Type_GETTASK = 7,
  Request_Type_SETTASK = 8,
  Request_Type_GETSTUDENT = 9,
  Request_Type_JOINCLASS = 10,
  Request_Type_GETLOGLIST = 11,
  Request_Type_GETLOGDATA = 12,
  Request_Type_CLEARLOGS = 13,
  Request_Type_SHUTDOWN = 14,
  Request_Type_RESTART = 15,
  Request_Type_TEST = 16,
  Request_Type_Request_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Request_Type_Request_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Request_Type_IsValid(int value);
constexpr Request_Type Request_Type_Type_MIN = Request_Type_LOGIN;
constexpr Request_Type Request_Type_Type_MAX = Request_Type_TEST;
constexpr int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_Type_descriptor();
template<typename T>
inline const std::string& Request_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_Type_descriptor(), enum_t_value);
}
inline bool Request_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Answer_Type : int {
  Answer_Type_ERROR = 0,
  Answer_Type_DONE = 1,
  Answer_Type_DENIED = 2,
  Answer_Type_Answer_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Answer_Type_Answer_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Answer_Type_IsValid(int value);
constexpr Answer_Type Answer_Type_Type_MIN = Answer_Type_ERROR;
constexpr Answer_Type Answer_Type_Type_MAX = Answer_Type_DENIED;
constexpr int Answer_Type_Type_ARRAYSIZE = Answer_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Answer_Type_descriptor();
template<typename T>
inline const std::string& Answer_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Answer_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Answer_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Answer_Type_descriptor(), enum_t_value);
}
inline bool Answer_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Answer_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Answer_Type>(
    Answer_Type_descriptor(), name, value);
}
// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JC.Net.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return new Request();
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JC.Net.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static constexpr Type LOGIN =
    Request_Type_LOGIN;
  static constexpr Type GETUSERLIST =
    Request_Type_GETUSERLIST;
  static constexpr Type ADDUSER =
    Request_Type_ADDUSER;
  static constexpr Type CHANGEUSER =
    Request_Type_CHANGEUSER;
  static constexpr Type DELUSER =
    Request_Type_DELUSER;
  static constexpr Type GETCONFIG =
    Request_Type_GETCONFIG;
  static constexpr Type SETCONFIG =
    Request_Type_SETCONFIG;
  static constexpr Type GETTASK =
    Request_Type_GETTASK;
  static constexpr Type SETTASK =
    Request_Type_SETTASK;
  static constexpr Type GETSTUDENT =
    Request_Type_GETSTUDENT;
  static constexpr Type JOINCLASS =
    Request_Type_JOINCLASS;
  static constexpr Type GETLOGLIST =
    Request_Type_GETLOGLIST;
  static constexpr Type GETLOGDATA =
    Request_Type_GETLOGDATA;
  static constexpr Type CLEARLOGS =
    Request_Type_CLEARLOGS;
  static constexpr Type SHUTDOWN =
    Request_Type_SHUTDOWN;
  static constexpr Type RESTART =
    Request_Type_RESTART;
  static constexpr Type TEST =
    Request_Type_TEST;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Request_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Request_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Request_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClassesFieldNumber = 7,
    kUserFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kConfigFieldNumber = 5,
    kLognameFieldNumber = 8,
    kNewuserFieldNumber = 4,
    kTaskFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // repeated string classes = 7;
  int classes_size() const;
  private:
  int _internal_classes_size() const;
  public:
  void clear_classes();
  const std::string& classes(int index) const;
  std::string* mutable_classes(int index);
  void set_classes(int index, const std::string& value);
  void set_classes(int index, std::string&& value);
  void set_classes(int index, const char* value);
  void set_classes(int index, const char* value, size_t size);
  std::string* add_classes();
  void add_classes(const std::string& value);
  void add_classes(std::string&& value);
  void add_classes(const char* value);
  void add_classes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& classes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_classes();
  private:
  const std::string& _internal_classes(int index) const;
  std::string* _internal_add_classes();
  public:

  // string user = 2;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // bytes password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string config = 5;
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_MUST_USE_RESULT std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // string logname = 8;
  void clear_logname();
  const std::string& logname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logname();
  PROTOBUF_MUST_USE_RESULT std::string* release_logname();
  void set_allocated_logname(std::string* logname);
  private:
  const std::string& _internal_logname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logname(const std::string& value);
  std::string* _internal_mutable_logname();
  public:

  // .JC.User newuser = 4;
  bool has_newuser() const;
  private:
  bool _internal_has_newuser() const;
  public:
  void clear_newuser();
  const ::JC::User& newuser() const;
  PROTOBUF_MUST_USE_RESULT ::JC::User* release_newuser();
  ::JC::User* mutable_newuser();
  void set_allocated_newuser(::JC::User* newuser);
  private:
  const ::JC::User& _internal_newuser() const;
  ::JC::User* _internal_mutable_newuser();
  public:
  void unsafe_arena_set_allocated_newuser(
      ::JC::User* newuser);
  ::JC::User* unsafe_arena_release_newuser();

  // .JC.Task task = 6;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::JC::Task& task() const;
  PROTOBUF_MUST_USE_RESULT ::JC::Task* release_task();
  ::JC::Task* mutable_task();
  void set_allocated_task(::JC::Task* task);
  private:
  const ::JC::Task& _internal_task() const;
  ::JC::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::JC::Task* task);
  ::JC::Task* unsafe_arena_release_task();

  // .JC.Net.Request.Type type = 1;
  void clear_type();
  ::JC::Net::Request_Type type() const;
  void set_type(::JC::Net::Request_Type value);
  private:
  ::JC::Net::Request_Type _internal_type() const;
  void _internal_set_type(::JC::Net::Request_Type value);
  public:

  // @@protoc_insertion_point(class_scope:JC.Net.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> classes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logname_;
  ::JC::User* newuser_;
  ::JC::Task* task_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JC.Net.Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit constexpr Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Answer* New() const final {
    return new Answer();
  }

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Answer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Answer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JC.Net.Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Answer_Type Type;
  static constexpr Type ERROR =
    Answer_Type_ERROR;
  static constexpr Type DONE =
    Answer_Type_DONE;
  static constexpr Type DENIED =
    Answer_Type_DENIED;
  static inline bool Type_IsValid(int value) {
    return Answer_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Answer_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Answer_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Answer_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Answer_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Answer_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Answer_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClassesFieldNumber = 5,
    kLogListFieldNumber = 7,
    kUserListFieldNumber = 9,
    kMesageFieldNumber = 2,
    kLogDataFieldNumber = 8,
    kConfigFieldNumber = 10,
    kTaskFieldNumber = 4,
    kStudentFieldNumber = 6,
    kTypeFieldNumber = 1,
    kUserTypeFieldNumber = 3,
  };
  // repeated .JC.Class classes = 5;
  int classes_size() const;
  private:
  int _internal_classes_size() const;
  public:
  void clear_classes();
  ::JC::Class* mutable_classes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::Class >*
      mutable_classes();
  private:
  const ::JC::Class& _internal_classes(int index) const;
  ::JC::Class* _internal_add_classes();
  public:
  const ::JC::Class& classes(int index) const;
  ::JC::Class* add_classes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::Class >&
      classes() const;

  // repeated string logList = 7;
  int loglist_size() const;
  private:
  int _internal_loglist_size() const;
  public:
  void clear_loglist();
  const std::string& loglist(int index) const;
  std::string* mutable_loglist(int index);
  void set_loglist(int index, const std::string& value);
  void set_loglist(int index, std::string&& value);
  void set_loglist(int index, const char* value);
  void set_loglist(int index, const char* value, size_t size);
  std::string* add_loglist();
  void add_loglist(const std::string& value);
  void add_loglist(std::string&& value);
  void add_loglist(const char* value);
  void add_loglist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& loglist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_loglist();
  private:
  const std::string& _internal_loglist(int index) const;
  std::string* _internal_add_loglist();
  public:

  // repeated .JC.User userList = 9;
  int userlist_size() const;
  private:
  int _internal_userlist_size() const;
  public:
  void clear_userlist();
  ::JC::User* mutable_userlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::User >*
      mutable_userlist();
  private:
  const ::JC::User& _internal_userlist(int index) const;
  ::JC::User* _internal_add_userlist();
  public:
  const ::JC::User& userlist(int index) const;
  ::JC::User* add_userlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::User >&
      userlist() const;

  // string mesage = 2;
  void clear_mesage();
  const std::string& mesage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mesage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mesage();
  PROTOBUF_MUST_USE_RESULT std::string* release_mesage();
  void set_allocated_mesage(std::string* mesage);
  private:
  const std::string& _internal_mesage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mesage(const std::string& value);
  std::string* _internal_mutable_mesage();
  public:

  // string logData = 8;
  void clear_logdata();
  const std::string& logdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_logdata();
  void set_allocated_logdata(std::string* logdata);
  private:
  const std::string& _internal_logdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logdata(const std::string& value);
  std::string* _internal_mutable_logdata();
  public:

  // string config = 10;
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_MUST_USE_RESULT std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // .JC.Task task = 4;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::JC::Task& task() const;
  PROTOBUF_MUST_USE_RESULT ::JC::Task* release_task();
  ::JC::Task* mutable_task();
  void set_allocated_task(::JC::Task* task);
  private:
  const ::JC::Task& _internal_task() const;
  ::JC::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::JC::Task* task);
  ::JC::Task* unsafe_arena_release_task();

  // .JC.Student student = 6;
  bool has_student() const;
  private:
  bool _internal_has_student() const;
  public:
  void clear_student();
  const ::JC::Student& student() const;
  PROTOBUF_MUST_USE_RESULT ::JC::Student* release_student();
  ::JC::Student* mutable_student();
  void set_allocated_student(::JC::Student* student);
  private:
  const ::JC::Student& _internal_student() const;
  ::JC::Student* _internal_mutable_student();
  public:
  void unsafe_arena_set_allocated_student(
      ::JC::Student* student);
  ::JC::Student* unsafe_arena_release_student();

  // .JC.Net.Answer.Type type = 1;
  void clear_type();
  ::JC::Net::Answer_Type type() const;
  void set_type(::JC::Net::Answer_Type value);
  private:
  ::JC::Net::Answer_Type _internal_type() const;
  void _internal_set_type(::JC::Net::Answer_Type value);
  public:

  // .JC.User.Type userType = 3;
  void clear_usertype();
  ::JC::User_Type usertype() const;
  void set_usertype(::JC::User_Type value);
  private:
  ::JC::User_Type _internal_usertype() const;
  void _internal_set_usertype(::JC::User_Type value);
  public:

  // @@protoc_insertion_point(class_scope:JC.Net.Answer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::Class > classes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> loglist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::User > userlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mesage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logdata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
  ::JC::Task* task_;
  ::JC::Student* student_;
  int type_;
  int usertype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class RequestPack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JC.Net.RequestPack) */ {
 public:
  inline RequestPack() : RequestPack(nullptr) {}
  ~RequestPack() override;
  explicit constexpr RequestPack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPack(const RequestPack& from);
  RequestPack(RequestPack&& from) noexcept
    : RequestPack() {
    *this = ::std::move(from);
  }

  inline RequestPack& operator=(const RequestPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPack& operator=(RequestPack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPack& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPack* internal_default_instance() {
    return reinterpret_cast<const RequestPack*>(
               &_RequestPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestPack& a, RequestPack& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestPack* New() const final {
    return new RequestPack();
  }

  RequestPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestPack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestPack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JC.Net.RequestPack";
  }
  protected:
  explicit RequestPack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kPackFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .JC.Net.Request pack = 2;
  bool has_pack() const;
  private:
  bool _internal_has_pack() const;
  public:
  void clear_pack();
  const ::JC::Net::Request& pack() const;
  PROTOBUF_MUST_USE_RESULT ::JC::Net::Request* release_pack();
  ::JC::Net::Request* mutable_pack();
  void set_allocated_pack(::JC::Net::Request* pack);
  private:
  const ::JC::Net::Request& _internal_pack() const;
  ::JC::Net::Request* _internal_mutable_pack();
  public:
  void unsafe_arena_set_allocated_pack(
      ::JC::Net::Request* pack);
  ::JC::Net::Request* unsafe_arena_release_pack();

  // @@protoc_insertion_point(class_scope:JC.Net.RequestPack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::JC::Net::Request* pack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class AnswerPack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JC.Net.AnswerPack) */ {
 public:
  inline AnswerPack() : AnswerPack(nullptr) {}
  ~AnswerPack() override;
  explicit constexpr AnswerPack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerPack(const AnswerPack& from);
  AnswerPack(AnswerPack&& from) noexcept
    : AnswerPack() {
    *this = ::std::move(from);
  }

  inline AnswerPack& operator=(const AnswerPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerPack& operator=(AnswerPack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerPack& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerPack* internal_default_instance() {
    return reinterpret_cast<const AnswerPack*>(
               &_AnswerPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AnswerPack& a, AnswerPack& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerPack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerPack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnswerPack* New() const final {
    return new AnswerPack();
  }

  AnswerPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnswerPack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerPack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnswerPack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JC.Net.AnswerPack";
  }
  protected:
  explicit AnswerPack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kPackFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .JC.Net.Answer pack = 2;
  bool has_pack() const;
  private:
  bool _internal_has_pack() const;
  public:
  void clear_pack();
  const ::JC::Net::Answer& pack() const;
  PROTOBUF_MUST_USE_RESULT ::JC::Net::Answer* release_pack();
  ::JC::Net::Answer* mutable_pack();
  void set_allocated_pack(::JC::Net::Answer* pack);
  private:
  const ::JC::Net::Answer& _internal_pack() const;
  ::JC::Net::Answer* _internal_mutable_pack();
  public:
  void unsafe_arena_set_allocated_pack(
      ::JC::Net::Answer* pack);
  ::JC::Net::Answer* unsafe_arena_release_pack();

  // @@protoc_insertion_point(class_scope:JC.Net.AnswerPack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::JC::Net::Answer* pack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_net_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// .JC.Net.Request.Type type = 1;
inline void Request::clear_type() {
  type_ = 0;
}
inline ::JC::Net::Request_Type Request::_internal_type() const {
  return static_cast< ::JC::Net::Request_Type >(type_);
}
inline ::JC::Net::Request_Type Request::type() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.type)
  return _internal_type();
}
inline void Request::_internal_set_type(::JC::Net::Request_Type value) {
  
  type_ = value;
}
inline void Request::set_type(::JC::Net::Request_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:JC.Net.Request.type)
}

// string user = 2;
inline void Request::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& Request::user() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Request.user)
}
inline std::string* Request::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.user)
  return _s;
}
inline const std::string& Request::_internal_user() const {
  return user_.Get();
}
inline void Request::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_user() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.user)
}

// bytes password = 3;
inline void Request::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& Request::password() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Request.password)
}
inline std::string* Request::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.password)
  return _s;
}
inline const std::string& Request::_internal_password() const {
  return password_.Get();
}
inline void Request::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_password() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.password)
}

// .JC.User newuser = 4;
inline bool Request::_internal_has_newuser() const {
  return this != internal_default_instance() && newuser_ != nullptr;
}
inline bool Request::has_newuser() const {
  return _internal_has_newuser();
}
inline const ::JC::User& Request::_internal_newuser() const {
  const ::JC::User* p = newuser_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::User&>(
      ::JC::_User_default_instance_);
}
inline const ::JC::User& Request::newuser() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.newuser)
  return _internal_newuser();
}
inline void Request::unsafe_arena_set_allocated_newuser(
    ::JC::User* newuser) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newuser_);
  }
  newuser_ = newuser;
  if (newuser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.Request.newuser)
}
inline ::JC::User* Request::release_newuser() {
  
  ::JC::User* temp = newuser_;
  newuser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::User* Request::unsafe_arena_release_newuser() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.newuser)
  
  ::JC::User* temp = newuser_;
  newuser_ = nullptr;
  return temp;
}
inline ::JC::User* Request::_internal_mutable_newuser() {
  
  if (newuser_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::User>(GetArenaForAllocation());
    newuser_ = p;
  }
  return newuser_;
}
inline ::JC::User* Request::mutable_newuser() {
  ::JC::User* _msg = _internal_mutable_newuser();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.newuser)
  return _msg;
}
inline void Request::set_allocated_newuser(::JC::User* newuser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(newuser_);
  }
  if (newuser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newuser));
    if (message_arena != submessage_arena) {
      newuser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newuser, submessage_arena);
    }
    
  } else {
    
  }
  newuser_ = newuser;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.newuser)
}

// string config = 5;
inline void Request::clear_config() {
  config_.ClearToEmpty();
}
inline const std::string& Request::config() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_config(ArgT0&& arg0, ArgT... args) {
 
 config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Request.config)
}
inline std::string* Request::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.config)
  return _s;
}
inline const std::string& Request::_internal_config() const {
  return config_.Get();
}
inline void Request::_internal_set_config(const std::string& value) {
  
  config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_config() {
  
  return config_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_config() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.config)
  return config_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.config)
}

// .JC.Task task = 6;
inline bool Request::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool Request::has_task() const {
  return _internal_has_task();
}
inline const ::JC::Task& Request::_internal_task() const {
  const ::JC::Task* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::Task&>(
      ::JC::_Task_default_instance_);
}
inline const ::JC::Task& Request::task() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.task)
  return _internal_task();
}
inline void Request::unsafe_arena_set_allocated_task(
    ::JC::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.Request.task)
}
inline ::JC::Task* Request::release_task() {
  
  ::JC::Task* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::Task* Request::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.task)
  
  ::JC::Task* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::JC::Task* Request::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::Task>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::JC::Task* Request::mutable_task() {
  ::JC::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.task)
  return _msg;
}
inline void Request::set_allocated_task(::JC::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task));
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.task)
}

// repeated string classes = 7;
inline int Request::_internal_classes_size() const {
  return classes_.size();
}
inline int Request::classes_size() const {
  return _internal_classes_size();
}
inline void Request::clear_classes() {
  classes_.Clear();
}
inline std::string* Request::add_classes() {
  std::string* _s = _internal_add_classes();
  // @@protoc_insertion_point(field_add_mutable:JC.Net.Request.classes)
  return _s;
}
inline const std::string& Request::_internal_classes(int index) const {
  return classes_.Get(index);
}
inline const std::string& Request::classes(int index) const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.classes)
  return _internal_classes(index);
}
inline std::string* Request::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.classes)
  return classes_.Mutable(index);
}
inline void Request::set_classes(int index, const std::string& value) {
  classes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:JC.Net.Request.classes)
}
inline void Request::set_classes(int index, std::string&& value) {
  classes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:JC.Net.Request.classes)
}
inline void Request::set_classes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:JC.Net.Request.classes)
}
inline void Request::set_classes(int index, const char* value, size_t size) {
  classes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JC.Net.Request.classes)
}
inline std::string* Request::_internal_add_classes() {
  return classes_.Add();
}
inline void Request::add_classes(const std::string& value) {
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:JC.Net.Request.classes)
}
inline void Request::add_classes(std::string&& value) {
  classes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:JC.Net.Request.classes)
}
inline void Request::add_classes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:JC.Net.Request.classes)
}
inline void Request::add_classes(const char* value, size_t size) {
  classes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:JC.Net.Request.classes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Request::classes() const {
  // @@protoc_insertion_point(field_list:JC.Net.Request.classes)
  return classes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Request::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:JC.Net.Request.classes)
  return &classes_;
}

// string logname = 8;
inline void Request::clear_logname() {
  logname_.ClearToEmpty();
}
inline const std::string& Request::logname() const {
  // @@protoc_insertion_point(field_get:JC.Net.Request.logname)
  return _internal_logname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_logname(ArgT0&& arg0, ArgT... args) {
 
 logname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Request.logname)
}
inline std::string* Request::mutable_logname() {
  std::string* _s = _internal_mutable_logname();
  // @@protoc_insertion_point(field_mutable:JC.Net.Request.logname)
  return _s;
}
inline const std::string& Request::_internal_logname() const {
  return logname_.Get();
}
inline void Request::_internal_set_logname(const std::string& value) {
  
  logname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_logname() {
  
  return logname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_logname() {
  // @@protoc_insertion_point(field_release:JC.Net.Request.logname)
  return logname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_logname(std::string* logname) {
  if (logname != nullptr) {
    
  } else {
    
  }
  logname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Request.logname)
}

// -------------------------------------------------------------------

// Answer

// .JC.Net.Answer.Type type = 1;
inline void Answer::clear_type() {
  type_ = 0;
}
inline ::JC::Net::Answer_Type Answer::_internal_type() const {
  return static_cast< ::JC::Net::Answer_Type >(type_);
}
inline ::JC::Net::Answer_Type Answer::type() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.type)
  return _internal_type();
}
inline void Answer::_internal_set_type(::JC::Net::Answer_Type value) {
  
  type_ = value;
}
inline void Answer::set_type(::JC::Net::Answer_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:JC.Net.Answer.type)
}

// string mesage = 2;
inline void Answer::clear_mesage() {
  mesage_.ClearToEmpty();
}
inline const std::string& Answer::mesage() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.mesage)
  return _internal_mesage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_mesage(ArgT0&& arg0, ArgT... args) {
 
 mesage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Answer.mesage)
}
inline std::string* Answer::mutable_mesage() {
  std::string* _s = _internal_mutable_mesage();
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.mesage)
  return _s;
}
inline const std::string& Answer::_internal_mesage() const {
  return mesage_.Get();
}
inline void Answer::_internal_set_mesage(const std::string& value) {
  
  mesage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_mesage() {
  
  return mesage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Answer::release_mesage() {
  // @@protoc_insertion_point(field_release:JC.Net.Answer.mesage)
  return mesage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Answer::set_allocated_mesage(std::string* mesage) {
  if (mesage != nullptr) {
    
  } else {
    
  }
  mesage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mesage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Answer.mesage)
}

// .JC.User.Type userType = 3;
inline void Answer::clear_usertype() {
  usertype_ = 0;
}
inline ::JC::User_Type Answer::_internal_usertype() const {
  return static_cast< ::JC::User_Type >(usertype_);
}
inline ::JC::User_Type Answer::usertype() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.userType)
  return _internal_usertype();
}
inline void Answer::_internal_set_usertype(::JC::User_Type value) {
  
  usertype_ = value;
}
inline void Answer::set_usertype(::JC::User_Type value) {
  _internal_set_usertype(value);
  // @@protoc_insertion_point(field_set:JC.Net.Answer.userType)
}

// .JC.Task task = 4;
inline bool Answer::_internal_has_task() const {
  return this != internal_default_instance() && task_ != nullptr;
}
inline bool Answer::has_task() const {
  return _internal_has_task();
}
inline const ::JC::Task& Answer::_internal_task() const {
  const ::JC::Task* p = task_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::Task&>(
      ::JC::_Task_default_instance_);
}
inline const ::JC::Task& Answer::task() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.task)
  return _internal_task();
}
inline void Answer::unsafe_arena_set_allocated_task(
    ::JC::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.Answer.task)
}
inline ::JC::Task* Answer::release_task() {
  
  ::JC::Task* temp = task_;
  task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::Task* Answer::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:JC.Net.Answer.task)
  
  ::JC::Task* temp = task_;
  task_ = nullptr;
  return temp;
}
inline ::JC::Task* Answer::_internal_mutable_task() {
  
  if (task_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::Task>(GetArenaForAllocation());
    task_ = p;
  }
  return task_;
}
inline ::JC::Task* Answer::mutable_task() {
  ::JC::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.task)
  return _msg;
}
inline void Answer::set_allocated_task(::JC::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_);
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task));
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Answer.task)
}

// repeated .JC.Class classes = 5;
inline int Answer::_internal_classes_size() const {
  return classes_.size();
}
inline int Answer::classes_size() const {
  return _internal_classes_size();
}
inline ::JC::Class* Answer::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.classes)
  return classes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::Class >*
Answer::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:JC.Net.Answer.classes)
  return &classes_;
}
inline const ::JC::Class& Answer::_internal_classes(int index) const {
  return classes_.Get(index);
}
inline const ::JC::Class& Answer::classes(int index) const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.classes)
  return _internal_classes(index);
}
inline ::JC::Class* Answer::_internal_add_classes() {
  return classes_.Add();
}
inline ::JC::Class* Answer::add_classes() {
  ::JC::Class* _add = _internal_add_classes();
  // @@protoc_insertion_point(field_add:JC.Net.Answer.classes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::Class >&
Answer::classes() const {
  // @@protoc_insertion_point(field_list:JC.Net.Answer.classes)
  return classes_;
}

// .JC.Student student = 6;
inline bool Answer::_internal_has_student() const {
  return this != internal_default_instance() && student_ != nullptr;
}
inline bool Answer::has_student() const {
  return _internal_has_student();
}
inline const ::JC::Student& Answer::_internal_student() const {
  const ::JC::Student* p = student_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::Student&>(
      ::JC::_Student_default_instance_);
}
inline const ::JC::Student& Answer::student() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.student)
  return _internal_student();
}
inline void Answer::unsafe_arena_set_allocated_student(
    ::JC::Student* student) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(student_);
  }
  student_ = student;
  if (student) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.Answer.student)
}
inline ::JC::Student* Answer::release_student() {
  
  ::JC::Student* temp = student_;
  student_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::Student* Answer::unsafe_arena_release_student() {
  // @@protoc_insertion_point(field_release:JC.Net.Answer.student)
  
  ::JC::Student* temp = student_;
  student_ = nullptr;
  return temp;
}
inline ::JC::Student* Answer::_internal_mutable_student() {
  
  if (student_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::Student>(GetArenaForAllocation());
    student_ = p;
  }
  return student_;
}
inline ::JC::Student* Answer::mutable_student() {
  ::JC::Student* _msg = _internal_mutable_student();
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.student)
  return _msg;
}
inline void Answer::set_allocated_student(::JC::Student* student) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(student_);
  }
  if (student) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(student));
    if (message_arena != submessage_arena) {
      student = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, student, submessage_arena);
    }
    
  } else {
    
  }
  student_ = student;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Answer.student)
}

// repeated string logList = 7;
inline int Answer::_internal_loglist_size() const {
  return loglist_.size();
}
inline int Answer::loglist_size() const {
  return _internal_loglist_size();
}
inline void Answer::clear_loglist() {
  loglist_.Clear();
}
inline std::string* Answer::add_loglist() {
  std::string* _s = _internal_add_loglist();
  // @@protoc_insertion_point(field_add_mutable:JC.Net.Answer.logList)
  return _s;
}
inline const std::string& Answer::_internal_loglist(int index) const {
  return loglist_.Get(index);
}
inline const std::string& Answer::loglist(int index) const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.logList)
  return _internal_loglist(index);
}
inline std::string* Answer::mutable_loglist(int index) {
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.logList)
  return loglist_.Mutable(index);
}
inline void Answer::set_loglist(int index, const std::string& value) {
  loglist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:JC.Net.Answer.logList)
}
inline void Answer::set_loglist(int index, std::string&& value) {
  loglist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:JC.Net.Answer.logList)
}
inline void Answer::set_loglist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  loglist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:JC.Net.Answer.logList)
}
inline void Answer::set_loglist(int index, const char* value, size_t size) {
  loglist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JC.Net.Answer.logList)
}
inline std::string* Answer::_internal_add_loglist() {
  return loglist_.Add();
}
inline void Answer::add_loglist(const std::string& value) {
  loglist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:JC.Net.Answer.logList)
}
inline void Answer::add_loglist(std::string&& value) {
  loglist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:JC.Net.Answer.logList)
}
inline void Answer::add_loglist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  loglist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:JC.Net.Answer.logList)
}
inline void Answer::add_loglist(const char* value, size_t size) {
  loglist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:JC.Net.Answer.logList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Answer::loglist() const {
  // @@protoc_insertion_point(field_list:JC.Net.Answer.logList)
  return loglist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Answer::mutable_loglist() {
  // @@protoc_insertion_point(field_mutable_list:JC.Net.Answer.logList)
  return &loglist_;
}

// string logData = 8;
inline void Answer::clear_logdata() {
  logdata_.ClearToEmpty();
}
inline const std::string& Answer::logdata() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.logData)
  return _internal_logdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_logdata(ArgT0&& arg0, ArgT... args) {
 
 logdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Answer.logData)
}
inline std::string* Answer::mutable_logdata() {
  std::string* _s = _internal_mutable_logdata();
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.logData)
  return _s;
}
inline const std::string& Answer::_internal_logdata() const {
  return logdata_.Get();
}
inline void Answer::_internal_set_logdata(const std::string& value) {
  
  logdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_logdata() {
  
  return logdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Answer::release_logdata() {
  // @@protoc_insertion_point(field_release:JC.Net.Answer.logData)
  return logdata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Answer::set_allocated_logdata(std::string* logdata) {
  if (logdata != nullptr) {
    
  } else {
    
  }
  logdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Answer.logData)
}

// repeated .JC.User userList = 9;
inline int Answer::_internal_userlist_size() const {
  return userlist_.size();
}
inline int Answer::userlist_size() const {
  return _internal_userlist_size();
}
inline ::JC::User* Answer::mutable_userlist(int index) {
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.userList)
  return userlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::User >*
Answer::mutable_userlist() {
  // @@protoc_insertion_point(field_mutable_list:JC.Net.Answer.userList)
  return &userlist_;
}
inline const ::JC::User& Answer::_internal_userlist(int index) const {
  return userlist_.Get(index);
}
inline const ::JC::User& Answer::userlist(int index) const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.userList)
  return _internal_userlist(index);
}
inline ::JC::User* Answer::_internal_add_userlist() {
  return userlist_.Add();
}
inline ::JC::User* Answer::add_userlist() {
  ::JC::User* _add = _internal_add_userlist();
  // @@protoc_insertion_point(field_add:JC.Net.Answer.userList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JC::User >&
Answer::userlist() const {
  // @@protoc_insertion_point(field_list:JC.Net.Answer.userList)
  return userlist_;
}

// string config = 10;
inline void Answer::clear_config() {
  config_.ClearToEmpty();
}
inline const std::string& Answer::config() const {
  // @@protoc_insertion_point(field_get:JC.Net.Answer.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_config(ArgT0&& arg0, ArgT... args) {
 
 config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.Answer.config)
}
inline std::string* Answer::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:JC.Net.Answer.config)
  return _s;
}
inline const std::string& Answer::_internal_config() const {
  return config_.Get();
}
inline void Answer::_internal_set_config(const std::string& value) {
  
  config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_config() {
  
  return config_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Answer::release_config() {
  // @@protoc_insertion_point(field_release:JC.Net.Answer.config)
  return config_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Answer::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.Answer.config)
}

// -------------------------------------------------------------------

// RequestPack

// bytes signature = 1;
inline void RequestPack::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& RequestPack::signature() const {
  // @@protoc_insertion_point(field_get:JC.Net.RequestPack.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestPack::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.RequestPack.signature)
}
inline std::string* RequestPack::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:JC.Net.RequestPack.signature)
  return _s;
}
inline const std::string& RequestPack::_internal_signature() const {
  return signature_.Get();
}
inline void RequestPack::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestPack::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestPack::release_signature() {
  // @@protoc_insertion_point(field_release:JC.Net.RequestPack.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestPack::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.RequestPack.signature)
}

// .JC.Net.Request pack = 2;
inline bool RequestPack::_internal_has_pack() const {
  return this != internal_default_instance() && pack_ != nullptr;
}
inline bool RequestPack::has_pack() const {
  return _internal_has_pack();
}
inline void RequestPack::clear_pack() {
  if (GetArenaForAllocation() == nullptr && pack_ != nullptr) {
    delete pack_;
  }
  pack_ = nullptr;
}
inline const ::JC::Net::Request& RequestPack::_internal_pack() const {
  const ::JC::Net::Request* p = pack_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::Net::Request&>(
      ::JC::Net::_Request_default_instance_);
}
inline const ::JC::Net::Request& RequestPack::pack() const {
  // @@protoc_insertion_point(field_get:JC.Net.RequestPack.pack)
  return _internal_pack();
}
inline void RequestPack::unsafe_arena_set_allocated_pack(
    ::JC::Net::Request* pack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pack_);
  }
  pack_ = pack;
  if (pack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.RequestPack.pack)
}
inline ::JC::Net::Request* RequestPack::release_pack() {
  
  ::JC::Net::Request* temp = pack_;
  pack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::Net::Request* RequestPack::unsafe_arena_release_pack() {
  // @@protoc_insertion_point(field_release:JC.Net.RequestPack.pack)
  
  ::JC::Net::Request* temp = pack_;
  pack_ = nullptr;
  return temp;
}
inline ::JC::Net::Request* RequestPack::_internal_mutable_pack() {
  
  if (pack_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::Net::Request>(GetArenaForAllocation());
    pack_ = p;
  }
  return pack_;
}
inline ::JC::Net::Request* RequestPack::mutable_pack() {
  ::JC::Net::Request* _msg = _internal_mutable_pack();
  // @@protoc_insertion_point(field_mutable:JC.Net.RequestPack.pack)
  return _msg;
}
inline void RequestPack::set_allocated_pack(::JC::Net::Request* pack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pack_;
  }
  if (pack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JC::Net::Request>::GetOwningArena(pack);
    if (message_arena != submessage_arena) {
      pack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pack, submessage_arena);
    }
    
  } else {
    
  }
  pack_ = pack;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.RequestPack.pack)
}

// -------------------------------------------------------------------

// AnswerPack

// bytes signature = 1;
inline void AnswerPack::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& AnswerPack::signature() const {
  // @@protoc_insertion_point(field_get:JC.Net.AnswerPack.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnswerPack::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JC.Net.AnswerPack.signature)
}
inline std::string* AnswerPack::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:JC.Net.AnswerPack.signature)
  return _s;
}
inline const std::string& AnswerPack::_internal_signature() const {
  return signature_.Get();
}
inline void AnswerPack::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AnswerPack::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AnswerPack::release_signature() {
  // @@protoc_insertion_point(field_release:JC.Net.AnswerPack.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AnswerPack::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:JC.Net.AnswerPack.signature)
}

// .JC.Net.Answer pack = 2;
inline bool AnswerPack::_internal_has_pack() const {
  return this != internal_default_instance() && pack_ != nullptr;
}
inline bool AnswerPack::has_pack() const {
  return _internal_has_pack();
}
inline void AnswerPack::clear_pack() {
  if (GetArenaForAllocation() == nullptr && pack_ != nullptr) {
    delete pack_;
  }
  pack_ = nullptr;
}
inline const ::JC::Net::Answer& AnswerPack::_internal_pack() const {
  const ::JC::Net::Answer* p = pack_;
  return p != nullptr ? *p : reinterpret_cast<const ::JC::Net::Answer&>(
      ::JC::Net::_Answer_default_instance_);
}
inline const ::JC::Net::Answer& AnswerPack::pack() const {
  // @@protoc_insertion_point(field_get:JC.Net.AnswerPack.pack)
  return _internal_pack();
}
inline void AnswerPack::unsafe_arena_set_allocated_pack(
    ::JC::Net::Answer* pack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pack_);
  }
  pack_ = pack;
  if (pack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:JC.Net.AnswerPack.pack)
}
inline ::JC::Net::Answer* AnswerPack::release_pack() {
  
  ::JC::Net::Answer* temp = pack_;
  pack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::JC::Net::Answer* AnswerPack::unsafe_arena_release_pack() {
  // @@protoc_insertion_point(field_release:JC.Net.AnswerPack.pack)
  
  ::JC::Net::Answer* temp = pack_;
  pack_ = nullptr;
  return temp;
}
inline ::JC::Net::Answer* AnswerPack::_internal_mutable_pack() {
  
  if (pack_ == nullptr) {
    auto* p = CreateMaybeMessage<::JC::Net::Answer>(GetArenaForAllocation());
    pack_ = p;
  }
  return pack_;
}
inline ::JC::Net::Answer* AnswerPack::mutable_pack() {
  ::JC::Net::Answer* _msg = _internal_mutable_pack();
  // @@protoc_insertion_point(field_mutable:JC.Net.AnswerPack.pack)
  return _msg;
}
inline void AnswerPack::set_allocated_pack(::JC::Net::Answer* pack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pack_;
  }
  if (pack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::JC::Net::Answer>::GetOwningArena(pack);
    if (message_arena != submessage_arena) {
      pack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pack, submessage_arena);
    }
    
  } else {
    
  }
  pack_ = pack;
  // @@protoc_insertion_point(field_set_allocated:JC.Net.AnswerPack.pack)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Net
}  // namespace JC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::JC::Net::Request_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JC::Net::Request_Type>() {
  return ::JC::Net::Request_Type_descriptor();
}
template <> struct is_proto_enum< ::JC::Net::Answer_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JC::Net::Answer_Type>() {
  return ::JC::Net::Answer_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2eproto
